all: lib tests wrap examples

COMPILER = clang

ifeq ($(COMPILER),clang)
	CXX = $(CLANG_CXX)
	CXXWARNINGS = $(CLANG_CXXWARNINGS)
	CXXFLAGS = $(CLANG_CXXFLAGS) $(CXXWARNINGS)
else ifeq ($(COMPILER),gcc)
	CXX = $(GCC_CXX)
	CXXWARNINGS = $(GCC_CXXWARNINGS)
	CXXFLAGS = $(GCC_CXXFLAGS) $(CXXWARNINGS)
else
	CXX = $(COMPILER)
	CXXWARNINGS = $(OTHER_CXXWARNINGS)
	CXXFLAGS = $(OTHER_CXXWARNINGS) $(CXXWARNINGS)
endif


GCC_CXX = g++
GCC_CXXFLAGS = -std=c++14  -fPIC -O1
GCC_CXXWARNINGS=-Wall  -Wno-non-template-friend -Wno-unused

CLANG_CXX = clang++
CLANG_CXXFLAGS = -std=c++14 -fPIC -O1
CLANG_CXXWARNINGS=-Wall -Wno-unused

OTHER_CXXFLAGS = -std=c++14 -fPIC -O1
OTHER_CXXWARNINGS=-Wall

#   -Wno-unused-local-typedef -Wno-unused-const-variable -Wno-unused-variable  -Wno-unused-function -Wno-unused-comparison

VPATH = source test wrap examples \
	source/utility source/numeric source/expression source/algebra source/function source/geometry source/solvers source/dynamics source/hybrid source/output \
	examples/experimental

HDR = \
	standard.hpp numeric.hpp functional.hpp

# ariadne.hpp

LIB_NUMERIC_SRC = \
	logging.cpp operators.cpp logical.cpp integer.cpp dyadic.cpp rational.cpp decimal.cpp real.cpp \
	float64.cpp floatmp.cpp \
	float-user.cpp number.cpp

#	float-approximate.cpp float-lower.cpp float-upper.cpp float-validated.cpp float-exact.cpp \

TEST_NUMERIC_SRC = \
	check_numeric.cpp \
	test_logical.cpp test_integer.cpp test_rational.cpp test_real.cpp test_number.cpp \
	test_float.cpp test_validated_float.cpp \

#	test_numeric.cpp \

LIB_ALGEBRA_SRC = \
	vector.cpp matrix.cpp series.cpp multi_index.cpp expansion.cpp differential.cpp algebra.cpp \

TEST_ALGEBRA_SRC = \
	test_vector.cpp test_matrix.cpp test_series.cpp test_multi_index.cpp test_expansion.cpp test_differential.cpp \

LIB_FUNCTION_SRC = \
	affine.cpp polynomial.cpp affine_model.cpp taylor_model.cpp  \
	formula.cpp procedure.cpp \
	function.cpp function_model.cpp symbolic_function.cpp taylor_function.cpp  \

TEST_FUNCTION_SRC = \
	check_function.cpp \
	test_polynomial.cpp test_procedure.cpp test_function.cpp test_taylor_model.cpp test_taylor_function.cpp \

LIB_SOLVER_SRC = \
	solver.cpp \
	integrator.cpp \
	constraint_solver.cpp \
	simplex_algorithm.cpp \
	linear_programming.cpp \
	nonlinear_programming.cpp

TEST_SOLVER_SRC = \
	test_linear_programming.cpp test_nonlinear_programming.cpp test_integrator.cpp test_constraint_solver.cpp test_solvers.cpp \

LIB_GEOMETRY_SRC = \
	paver.cpp \
	point.cpp \
	interval.cpp \
	box.cpp \
	curve.cpp \
	function_set.cpp \
	grid_set.cpp \
	affine_set.cpp \
	enclosure.cpp \
	drawer.cpp \
	graphics.cpp

TEST_GEOMETRY_SRC = \
	test_interval.cpp test_box.cpp test_function_sets.cpp test_affine_sets.cpp test_paving.cpp test_grid_set.cpp \
	test_graphics.cpp \

LIB_DYNAMICS_SRC = \
	orbit.cpp \
	map_evolver.cpp \
	vector_field_evolver.cpp

TEST_DYNAMICS_SRC = \
	test_discrete_evolution.cpp \
	test_continuous_evolution.cpp

LIB_EXPRESSION_SRC = \
	expression.cpp \
	expression_set.cpp \

TEST_EXPRESSION_SRC = \
	test_expression.cpp \

LIB_HYBRID_SRC = \
	discrete_location.cpp \
	hybrid_set.cpp \
	hybrid_enclosure.cpp \
	hybrid_automaton.cpp \
	hybrid_automaton-composite.cpp \
	hybrid_automaton-restrictive.cpp \
	hybrid_simulator.cpp \
	hybrid_evolver.cpp \
	hybrid_reachability_analyser.cpp \
	hybrid_graphics.cpp \

TEST_HYBRID_SRC = \
	test_hybrid_set.cpp test_hybrid_graphics.cpp \
	test_hybrid_automaton.cpp test_hybrid_simulator.cpp \
	test_hybrid_evolver.cpp test_hybrid_evolution.cpp test_hybrid_reachability_analyser.cpp

LIB_EXTRAS_SRC = \
	c1_taylor_function.cpp \
	runge_kutta_integrator.cpp \
	geometry.cpp \
	textplot.cpp

LIB_SRC = $(LIB_NUMERIC_SRC) $(LIB_ALGEBRA_SRC) $(LIB_FUNCTION_SRC) $(LIB_SOLVER_SRC) $(LIB_GEOMETRY_SRC) $(LIB_DYNAMICS_SRC) $(LIB_EXPRESSION_SRC) $(LIB_HYBRID_SRC)

TESTS_SRC = $(TEST_NUMERIC_SRC) $(TEST_ALGEBRA_SRC) $(TEST_FUNCTION_SRC) $(TEST_SOLVER_SRC) $(TEST_GEOMETRY_SRC) $(TEST_DYNAMICS_SRC) $(TEST_EXPRESSION_SRC) $(TEST_HYBRID_SRC)

WRAP_PYTHON_SRC = \
	ariadne_module.cpp numeric_module.cpp utilities.cpp \
	numeric_submodule.cpp linear_algebra_submodule.cpp optimization_submodule.cpp \
	differentiation_submodule.cpp function_submodule.cpp calculus_submodule.cpp \
	geometry_submodule.cpp solver_submodule.cpp storage_submodule.cpp \
	system_submodule.cpp evolution_submodule.cpp graphics_submodule.cpp

WRAP_SRC = $(WRAP_PYTHON_SRC)

WRAP_HDR = utility.hpp

UNUSED_TESTS_SRC = \


EXAMPLES_SRC = \
	tutorial.cpp \
	bouncingball.cpp \
	watertank.cpp \
	heating.cpp \
	ballinabox.cpp \
	watertank-compositional.cpp \
	rectifier.cpp \

EXAMPLES_EXPERIMENTAL_SRC = \
	exponential.cpp \
	laser.cpp \
	circle.cpp \
	bouncing-walls.cpp \
	compute_crossings_issue.cpp

DEP_DIR = dep
OBJ_DIR = obj
BIN_DIR = bin
CHECK_DIR = check
#LIB_OBJ_DIR = $(OBJ_DIR)/lib
#TESTS_OBJ_DIR = $(OBJ_DIR)/test
#WRAP_OBJ_DIR = $(OBJ_DIR)/wrap
#EXAMPLES_OBJ_DIR = $(OBJ_DIR)/examples
LIB_OBJ_DIR = $(OBJ_DIR)
TESTS_OBJ_DIR = $(OBJ_DIR)
WRAP_OBJ_DIR = $(OBJ_DIR)
EXAMPLES_OBJ_DIR = $(OBJ_DIR)
TESTS_BIN_DIR = $(BIN_DIR)
EXAMPLES_BIN_DIR = $(BIN_DIR)

ARIADNE_LIB = libariadne.so
ARIADNE_NUMERIC_LIB = libariadne-numeric.so
ARIADNE_ALGEBRA_LIB = libariadne-algebra.so
ARIADNE_FUNCTION_LIB = libariadne-function.so

DEPS = $(patsubst %.cpp,$(DEP_DIR)/%.o.d,$(LIB_SRC) $(LIB_EXTRAS_SRC) $(TESTS_SRC) $(EXAMPLES_SRC)) \
	$(patsubst %.hpp.gch,dep/%.hpp.gch.d,$(PCH))

PCH = $(patsubst %.hpp,%.hpp.gch,$(HDR))
LIB_OBJ = $(patsubst %.cpp,$(LIB_OBJ_DIR)/%.o,$(LIB_SRC))
LIB_NUMERIC_OBJ = $(patsubst %.cpp,$(LIB_OBJ_DIR)/%.o,$(LIB_NUMERIC_SRC))
LIB_ALGEBRA_OBJ = $(patsubst %.cpp,$(LIB_OBJ_DIR)/%.o,$(LIB_ALGEBRA_SRC))
LIB_FUNCTION_OBJ = $(patsubst %.cpp,$(LIB_OBJ_DIR)/%.o,$(LIB_FUNCTION_SRC))
LIB_EXTRAS_OBJ = $(patsubst %.cpp,$(LIB_OBJ_DIR)/%.o,$(LIB_EXTRAS_SRC))
TESTS_OBJ = $(patsubst %.cpp,$(TESTS_OBJ_DIR)/%.o,$(TESTS_SRC))
TESTS_BIN = $(patsubst %.cpp,$(TESTS_BIN_DIR)/%,$(TESTS_SRC))
TEST_NUMERIC_BIN = $(patsubst %.cpp.o,$(TESTS_BIN_DIR)/%,$(TEST_NUMERIC_SRC))
TEST_ALGEBRA_BIN = $(patsubst %.cpp.o,$(TESTS_BIN_DIR)/%,$(TEST_ALGEBRA_SRC))
TEST_FUNCTION_BIN = $(patsubst %.cpp,$(TESTS_BIN_DIR)/%,$(TEST_FUNCTION_SRC))
WRAP_OBJ = $(patsubst %.cpp,$(WRAP_OBJ_DIR)/%.o,$(WRAP_SRC))
EXAMPLES_OBJ = $(patsubst %.cpp,$(EXAMPLES_OBJ_DIR)/%.o,$(EXAMPLES_SRC))
EXAMPLES_BIN = $(patsubst %.cpp,$(EXAMPLES_BIN_DIR)/%,$(EXAMPLES_SRC))
EXAMPLES_EXPERIMENTAL_OBJ = $(patsubst %.cpp,$(EXAMPLES_OBJ_DIR)/%.o,$(EXAMPLES_EXPERIMENTAL_SRC))
EXAMPLES_EXPERIMENTAL_BIN = $(patsubst %.cpp,$(EXAMPLES_BIN_DIR)/%,$(EXAMPLES_EXPERIMENTAL_SRC))

INCLUDE_PATHS =  -iquote. -iquote./source
LINK_LIBS=-lgmpxx -lgmp -lmpfr -lcairo -lboost_system -lboost_serialization

PYTHON_VERSION=2.7
PYTHON_INCLUDE_PATH=/usr/include/python$(PYTHON_VERSION)
PYTHON_LIBRARY=python$(PYTHON_VERSION)
PYTHON_LINK_LIBS=-lboost_python -l$(PYTHON_LIBRARY)

# Pull in dependency information
include $(DEPS)

phony: all help dirs deps hdr lib tests wrap examples check clean shiny

help:
	@echo "\nDEPS"=$(DEPS)
	@echo "\nPCH"=$(PCH)
	@echo "\nLIB_SRC="$(LIB_SRC)
	@echo "LIB_OBJ="$(LIB_OBJ)
	@echo "\nTESTS_SRC="$(TESTS_SRC)
	@echo "TESTS_OBJ="$(TESTS_OBJ)
	@echo "TESTS_BIN="$(TESTS_BIN)
	@echo "\nWRAP_SRC="$(WRAP_SRC)
	@echo "WRAP_OBJ="$(WRAP_OBJ)
	@echo "\nEXAMPLES_SRC="$(EXAMPLES_SRC)
	@echo "EXAMPLES_OBJ="$(EXAMPLES_OBJ)
	@echo "EXAMPLES_BIN="$(EXAMPLES_BIN)
	@echo "\nCOMPILER="$(COMPILER)
	@echo "CXX="$(CXX)

dirs:
	@mkdir -p $(DEP_DIR)
	@mkdir -p $(LIB_OBJ_DIR)
	@mkdir -p $(TESTS_OBJ_DIR)
	@mkdir -p $(WRAP_OBJ_DIR)
	@mkdir -p $(EXAMPLES_OBJ_DIR)
	@mkdir -p $(TESTS_BIN_DIR)
	@mkdir -p $(EXAMPLES_BIN_DIR)
	@mkdir -p $(CHECK_DIR)

deps: dirs $(DEPS)

helpdep:
	Secho $(DEPS)

hdr: dirs deps $(PCH)

lib: dirs deps hdr libariadne.so libariadne-function.so

wrap: lib $(WRAP_OBJ) ariadne.so numeric.so

tests: dirs $(TESTS_BIN) $(TESTS_OBJ) lib

check: tests
	@tried=0; failed=0; red='[0;31m'; green='[0;32m'; blue='[1;34m'; black='[m'; for test_exe in $(TESTS_BIN); do test_name=`basename $$test_exe`; echo "$$test_name:"; ./$$test_exe 1>$$test_exe.log; fails=$$?; tried=$$((tried+1)); if test $$fails -gt 0; then echo $$red"FAIL $$test_name: $$fails check(s) failed"$$black; failed=$$((failed+1)); else echo $$green"PASS $$test_name"$$black; fi; done; echo "$$failed out of $$tried tests failed"; mv test_*.png bin;

examples: dirs $(EXAMPLES_BIN) $(EXAMPLES_OBJ) lib

examples-experimental: dirs $(EXAMPLES_EXPERIMENTAL_BIN) $(EXAMPLES_EXPERIMENTAL_OBJ) lib

clean:
	@rm -f */*.gch* $(OBJ_DIR)/*.o *.so $(BIN_DIR)/*

shiny: clean
	@rm -rf $(DEP_DIR) $(OBJ_DIR) $(BIN_DIR) $(CHECK_DIR)
	@rm -f *.png *.d

$(DEP_DIR)/standard.hpp.gch.d: utility/standard.hpp | dirs
	@echo "Making dependencies for "$<
	@$(CXX) $(CXXFLAGS) $(INCLUDE_PATHS) -MM $< 2>/dev/null | sed 's|standard\.o:|utility\/standard\.hpp\.gch:|' > $@

$(DEP_DIR)/numeric.hpp.gch.d: numeric/numeric.hpp | dirs
	@echo "Making dependencies for "$<" with star "$*
	@$(CXX) $(CXXFLAGS) $(INCLUDE_PATHS) -MM $< 2>/dev/null | sed 's|\(.*\)\.o:|numeric\/\1\.hpp\.gch:|' > $@

$(DEP_DIR)/functional.hpp.gch.d: function/functional.hpp | dirs
	@echo "Making dependencies for "$<
	@$(CXX) $(CXXFLAGS) $(INCLUDE_PATHS) -MM $< 2>/dev/null | sed 's|functional\.o:|function/functional\.hpp\.gch:|' > $@

$(DEP_DIR)/boost_python.hpp.gch.d: wrap/boost_python.hpp | dirs
	@echo "Making dependencies for "$<
	@$(CXX) $(CXXFLAGS) $(INCLUDE_PATHS) -MM $< 2>/dev/null | sed 's|boost_python\.o:|boost_python\.hpp\.gch:|' > $@


$(DEP_DIR)/%.o.d: %.cpp | dirs
	@echo "Making dependencies for "$<
	@$(CXX) $(CXXFLAGS) $(INCLUDE_PATHS) -I$(PYTHON_INCLUDE_PATH) -MM $< > $(DEP_DIR)/$*.o.d
	@sed -i  's|$*.o:|$(OBJ_DIR)/$*.o:|' $(DEP_DIR)/$*.o.d
	@sed -i 's|utility\/standard\.hpp|utility\/standard\.hpp\.gch|g' $(DEP_DIR)/$*.o.d
	@sed -i 's|numeric\/numeric\.hpp|numeric\/numeric\.hpp\.gch|g' $(DEP_DIR)/$*.o.d
	@sed -i 's|function\/functional\.hpp|function\/function\.hpp\.gch|g' $(DEP_DIR)/$*.o.d


libariadne.so: $(LIB_OBJ)
	$(CXX) $(LIB_OBJ) $(LINK_LIBS) -shared -o libariadne.so

libariadne-numeric.so: $(LIB_NUMERIC_OBJ)
	$(CXX) $(LIB_NUMERIC_OBJ) $(LINK_LIBS) -shared -o libariadne-numeric.so

libariadne-algebra.so: $(LIB_NUMERIC_OBJ) $(LIB_ALGEBRA_OBJ)  $(LIB_OBJ_DIR)/interval.o $(LIB_OBJ_DIR)/point.o $(LIB_OBJ_DIR)/box.o
	$(CXX) $(LIB_NUMERIC_OBJ) $(LIB_ALGEBRA_OBJ)  $(LIB_OBJ_DIR)/interval.o $(LIB_OBJ_DIR)/point.o $(LIB_OBJ_DIR)/box.o  $(LINK_LIBS) -shared -o libariadne-algebra.so

libariadne-function.so: $(LIB_NUMERIC_OBJ) $(LIB_ALGEBRA_OBJ) $(LIB_FUNCTION_OBJ)  $(LIB_OBJ_DIR)/expression.o $(LIB_OBJ_DIR)/interval.o $(LIB_OBJ_DIR)/point.o $(LIB_OBJ_DIR)/box.o
	$(CXX) $(LIB_NUMERIC_OBJ) $(LIB_ALGEBRA_OBJ) $(LIB_FUNCTION_OBJ) $(LIB_OBJ_DIR)/expression.o $(LIB_OBJ_DIR)/interval.o $(LIB_OBJ_DIR)/point.o  $(LIB_OBJ_DIR)/box.o  $(LINK_LIBS) -shared -o libariadne-function.so

ariadne.so: $(WRAP_OBJ) $(LIB_EXTRAS_OBJ) libariadne.so
	$(CXX) $(WRAP_OBJ) $(LIB_EXTRAS_OBJ) $(PYTHON_LINK_LIBS) libariadne.so -shared -o ariadne.so

numeric.so: $(WRAP_OBJ_DIR)/numeric_module.o $(WRAP_OBJ_DIR)/numeric_submodule.o libariadne-numeric.so
	$(CXX) $(WRAP_OBJ_DIR)/numeric_module.o $(WRAP_OBJ_DIR)/numeric_submodule.o $(PYTHON_LINK_LIBS) libariadne-numeric.so -shared -o numeric.so

algebra.so: $(WRAP_OBJ_DIR)/algebra_module.o $(WRAP_OBJ_DIR)/numeric_submodule.o $(WRAP_OBJ_DIR)/linear_algebra_submodule.o $(WRAP_OBJ_DIR)/differentiation_submodule.o $(WRAP_OBJ_DIR)/calculus_submodule.o libariadne.so
	$(CXX) $(WRAP_OBJ_DIR)/algebra_module.o $(WRAP_OBJ_DIR)/numeric_submodule.o $(WRAP_OBJ_DIR)/linear_algebra_submodule.o $(WRAP_OBJ_DIR)/differentiation_submodule.o $(WRAP_OBJ_DIR)/calculus_submodule.o $(PYTHON_LINK_LIBS) libariadne.so -shared -o linalg.so

%.hpp.gch: %.hpp
	$(CXX) $(CXXFLAGS) $(INCLUDE_PATHS) $<

wrap/boost_python.hpp.gch: wrap/boost_python.hpp
	$(CXX) $(CXXFLAGS) $(INCLUDE_PATHS) -I$(PYTHON_INCLUDE_PATH) $<

numeric/float.o: numeric/float.cpp
	$(CXX) $(CXXFLAGS) $(INCLUDE_PATHS) -c -o $@ $<

obj/%.o: %.cpp
	$(CXX) $(CXXFLAGS) $(INCLUDE_PATHS)  -I$(PYTHON_INCLUDE_PATH) -c -o $@ $<

obj/test_%.o: test/test_%.cpp
	$(CXX) $(CXXFLAGS) $(INCLUDE_PATHS) -c -o $@ $<

#FIXME: Make Python wrapper use its own compile rule
obj/%module.o: wrap/%module.cpp wrap/boost_python.hpp.gch
	$(CXX) $(CXXFLAGS) $(INCLUDE_PATHS) -I$(PYTHON_INCLUDE_PATH) -c -o $@ $<

obj/%.o: examples/%.cpp
	$(CXX) $(CXXFLAGS) $(INCLUDE_PATHS) -c -o $@ $<

bin/test_%: $(TESTS_OBJ_DIR)/test_%.o  libariadne.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_LIB) $(LINK_LIBS) -o $@


bin/check_numeric: $(TESTS_OBJ_DIR)/check_numeric.o
	$(CXX) $< $(LINK_FLAGS) -o $@

bin/check_function: $(TESTS_OBJ_DIR)/check_function.o
	$(CXX) $< $(LINK_FLAGS) -o $@

bin/test_numeric: $(TESTS_OBJ_DIR)/test_numeric.o  libariadne-numeric.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_NUMERIC_LIB) $(LINK_LIBS) -o $@

bin/test_logical: $(TESTS_OBJ_DIR)/test_logical.o  libariadne-numeric.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_NUMERIC_LIB) $(LINK_LIBS) -o $@

bin/test_integer: $(TESTS_OBJ_DIR)/test_integer.o  libariadne-numeric.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_NUMERIC_LIB) $(LINK_LIBS) -o $@

bin/test_rational: $(TESTS_OBJ_DIR)/test_rational.o  libariadne-numeric.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_NUMERIC_LIB) $(LINK_LIBS) -o $@

bin/test_real: $(TESTS_OBJ_DIR)/test_real.o  libariadne-numeric.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_NUMERIC_LIB) $(LINK_LIBS) -o $@

bin/test_number: $(TESTS_OBJ_DIR)/test_number.o  libariadne-numeric.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_NUMERIC_LIB) $(LINK_LIBS) -o $@

bin/test_float: $(TESTS_OBJ_DIR)/test_float.o  libariadne-numeric.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_NUMERIC_LIB) $(LINK_LIBS) -o $@

bin/test_validated_float: $(TESTS_OBJ_DIR)/test_validated_float.o  libariadne-numeric.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_NUMERIC_LIB) $(LINK_LIBS) -o $@


bin/test_vector: $(TESTS_OBJ_DIR)/test_vector.o  libariadne-algebra.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_ALGEBRA_LIB) $(LINK_LIBS) -o $@

bin/test_matrix: $(TESTS_OBJ_DIR)/test_matrix.o  libariadne-algebra.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_ALGEBRA_LIB) $(LINK_LIBS) -o $@

bin/test_multi_index: $(TESTS_OBJ_DIR)/test_multi_index.o  libariadne-algebra.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_ALGEBRA_LIB) $(LINK_LIBS) -o $@

bin/test_expansion: $(TESTS_OBJ_DIR)/test_expansion.o  libariadne-algebra.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_ALGEBRA_LIB) $(LINK_LIBS) -o $@

bin/test_differential: $(TESTS_OBJ_DIR)/test_differential.o  libariadne-algebra.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_ALGEBRA_LIB) $(LINK_LIBS) -o $@


TEST_FUNCTION_EXTRA_OBJ = \
	$(LIB_OBJ_DIR)/box.o $(LIB_OBJ_DIR)/point.o $(LIB_OBJ_DIR)/expression.o

bin/test_polynomial: $(TESTS_OBJ_DIR)/test_polynomial.o  libariadne-function.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_FUNCTION_LIB) $(LINK_LIBS) -o $@

bin/test_taylor_model: $(TESTS_OBJ_DIR)/test_taylor_model.o $(LIB_OBJ_DIR)/taylor_model.o libariadne-function.so
	$(CXX) $< $(LIB_OBJ_DIR)/taylor_model.o $(LINK_FLAGS) libariadne-function.so $(LINK_LIBS) -o $@

bin/test_procedure: $(TESTS_OBJ_DIR)/test_procedure.o  libariadne-function.so $(TEST_FUNCTION_EXTRA_OBJ)
	$(CXX) $< $(LINK_FLAGS) $(TEST_FUNCTION_EXTRA_OBJ) $(ARIADNE_FUNCTION_LIB) $(LINK_LIBS) -o $@

bin/test_function: $(TESTS_OBJ_DIR)/test_function.o  libariadne-function.so $(TEST_FUNCTION_EXTRA_OBJ)
	$(CXX) $< $(LINK_FLAGS) $(TEST_FUNCTION_EXTRA_OBJ) $(ARIADNE_FUNCTION_LIB) $(LINK_LIBS) -o $@

bin/test_taylor_function: $(TESTS_OBJ_DIR)/test_taylor_function.o  libariadne-function.so $(TEST_FUNCTION_EXTRA_OBJ)
	$(CXX) $< $(LINK_FLAGS) $(TEST_FUNCTION_EXTRA_OBJ) $(ARIADNE_FUNCTION_LIB) $(LINK_LIBS) -o $@

bin/test_%: $(TESTS_OBJ_DIR)/test_%.o  libariadne.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_LIB) $(LINK_LIBS) -o $@


bin/%: $(EXAMPLES_OBJ_DIR)/%.o libariadne.so
	$(CXX) $< $(LINK_FLAGS) $(ARIADNE_LIB) $(LINK_LIBS) -o $@

#wrap/boost_python.hpp.gch: boost_python.hpp
#	$(CXX) $(CXXFLAGS) $< -I$(PYTHON_INCLUDE_PATH)

#.libs/numeric_submodule.o: numeric_submodule.cpp boost_python.hpp.gch integer.hpp rational.hpp float64.hpp
#	$(CXX) $(CXXFLAGS) -c -o $@ $< -I$(PYTHON_INCLUDE_PATH)
