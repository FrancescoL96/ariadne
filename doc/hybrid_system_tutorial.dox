/***************************************************************************
 *            hybrid_system_tutorial.dox
 *
 *  Copyright  2004-17  Pieter Collins
 *
 ****************************************************************************/

/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/*!

\file hybrid_system_tutorial.dox
\brief Tutorial on %Ariadne's features for analysing hybrid systems.

\page hybrid_system_tutorial_page Tutorial on Analysing Hybrid Systems

In this tutorial, we show how to use %Ariadne to model and analyse a hybrid automaton model of a simple heating system.

\section tutorial_system_model The Hybrid Automaton Model

The system represents a heating system used to control the temperature in a room. The temperature is affected by to the external temperature, which is assumed to vary sinusoidally, and is controlled by a heater which may either be on or off. The heater is turned on whenever the temperature falls below a certain threshold, and is turned off whenever the temperature rises above a certain threshold.

The system has two discrete modes, \f$\textsc{On}\f$ and \f$\textsc{Off}\f$, representing the state of the heater. There are three events, \f$\textsc{TurnOn}\f$, \f$\textsc{TurnOff}\f$ and \f$\textsc{Midnight}\f$; the first two representing switching the heater, and the last being a reset of the clock at the beginning of a new day.

The system has two continuous variables, \em temperature \f$T\f$ and \em time-of-day \f$\tau\f$.
The system is described by three parameters, the heater power \f$P\f$, the insulation level \f$K\f$, the average external temperature \f$T_\mathrm{av}\f$, the amplitude of the external temperature fluctuations \f$T_\mathrm{amp}\f$.

\f[ \dot{T} = P + K(T_\mathrm{av} + T_\mathrm{amp}\cos(2\pi t) - T); \quad \dot{t}=1. \f]

The heater is turned on whenever the temperature falls below \f$T_{\textsc{On}}\f$, and is turned off whenever the temperature rises above \f$T_{\textsc{Off}}\f$.

\section tutorial_building_system Building the Ariadne Hybrid Automaton

Define a function to create the hybrid automaton

\snippet tutorials/hybrid_evolution/hybrid_evolution_tutorial.cpp create_heating_system

This function first defines the constants which are used by the system.
It then defines the discrete variable "heating" describing the mode of the system,
two discrete state labels, and the discrete events which occur during the evolution.
It then declares the system variables \c T and \c C describing the temperature and the clock state.

The function then constructs the system itself.
The modes of the \c heating systems are described in terms of their discrete state and dynamics,
and the discrete transitions by providing guards and resets.
The \c clock systems is described similarly.
Finally, the complete heating system is described by composition.



\section tutorial_hybrid_system_evolution Computing the Continuous Evolution

The following function creates a HybridEvolver object, which is a class which can compute system evolution.

\snippet tutorials/hybrid_evolution/hybrid_evolution_tutorial.cpp create_evolver

We now compute an approximate simulation of the evolution of the system.

\snippet tutorials/hybrid_evolution/hybrid_evolution_tutorial.cpp simulate_evolution

We now compute a rigorous simulation of the evolution of the system, and over-approximation of a larger flow-tube.

\snippet tutorials/hybrid_evolution/hybrid_evolution_tutorial.cpp compute_evolution

In each case we first define the intial set and evolution time, and then compute trajectories using the \c Evolver object up to the evolution time. The computed dynamics are written to standard output and to a file, and the attained sets are plotted.


\section tutorial_main Main function

\snippet tutorials/hybrid_evolution/hybrid_evolution_tutorial.cpp main
*/

/*!

\page python_tutorial_page Python Tutorial

\section python_tutorial_linear_algebra LinearAlgebra


Vectors and matrices can be constructed by using Python list objects. Note that a string literal representing a Float must be possible to represent exactly. For example
\code
v=Vector( [1,2.2,Float(3.3),"4.5"] )
v=IntervalVector( [1,2.2,Float(3.3),"4.4",Interval(5.5,5.6) ] )
A=Matrix( [ [1,2.2,Float(3.3)], ["4.5",Float("5.75"),6.875] ] )
\endcode



\subsection python_tutorial_linear_algebra_slicing Slicing (Future addition)

In the future, it will be possible to create \c VectorSlice and \c MatrixSlice objects using Python's slicing operatior. As in Matlab and other C++ libraries, and unlike Python sequences, these operations return a "view" into the structure, and not a copy, so can be used for in-place modification.

The semantics of this operator have not been determined, since Python has different conventions from C++ libraries such as the STL \c valarray class, glas and uBlas \c vector classes and Matlab classes. For example, if \c v is the vector <c>[0,1,2,3,4,5,6,7,8,9]</c>, then different possibilities are

 - Python: <c> v[start:finish:stride] </c>  e.g. <c>v[1:6:2]</c> = <c>v[1:7:2]</c> = <c>[1,3,5]</c>;

 - C++ STL \c valarray : <c> v[slice(start,size,stride)]</c> e.g.  <c> v[slice(1,3,2)]</c>\c  = <c>[3,5,7]</c>;

 - C++ uBlas: \c <c> project(v,slice(start,stride,size)) </c>  e.g.  <c>project(v,slice(1,2,3))</c> = <c>[1,3,5]</c>;

 - C++ glas: \c <c> slice(start,finish,stride)) </c>  e.g.  <c>v[slice(1,6,2)])</c> = <c>v[slice(1,7,2)])</c> = <c>[1,3,5]</c>;

 - Matlab: <c> v(first:stride:last) </c> with one-based indexing; e.g. <c>v(2:2:6)</c> = <c>v(2:2;7)</c> = <c>[1,3,5]</c>;

The main design decision is whether to use a single "Ariadne" slicing semantics which is used for any and all interfaces, or whether to use the natural semantics for the given environment. For the C++ API, we could provide STL \c valarray semantics <c> v[slice(start,size,stride=1)] </c> and Python semantics <c> v[range(start,finish,stride=1)] </c>.

\sa  \ref LinearAlgebraModule, Ariadne::Vector, Ariadne::Matrix

<br><br>




\section python_tutorial_function Functions

Currently %Ariadne provides a \c FunctionInterface class which specifies functions \f$f:\R^n\rightarrow\R^m\f$, i.e. functions of a single vector-valued variable.

There are currently two ways of creating user-defined functions, either via the Python interface or in C++.

\subsection tutorial_function_python Python functions

An %Ariadne function can be constructed directly from a Python function.
\code
def henon_function(x):
    return [ 1.5-x[0]*x[0]+0.375*x[1], x[0] ]
\endcode
Note that there must be a single argument of sequence type (i.e. supporting subscripting), and that the result must be a Python \c list object.

To prepare the Python function for use in %Ariadne, some meta-information is required.
\code
henon_function.result_size = 2
henon_function.argument_size = 2
\endcode

Finally, the function can be exported to the C++ wrapper.
\code
henon = AriadneFunction(henon_function)
\endcode
The newly-created function can be used exactly as a native C++ function, and supports automatic differentiation.
\code
x=Vector([1,0])
print henon.evaluate(x)
print henon.jacobian(x)
print henon.derivative(x,3)
\endcode

An %Ariadne function can actually be constructed from any Python object with methods \c "result_size", \c "argument_size" and the special method \c "__call__". For example, to create a parameterised version of the Henon map, use:
\code
class HenonFunction:
    def __init__(self,p):
        self.p=p
        self.result_size=2
        self.argument_size=2
    def __call__(self,x):
        return [ p[0]-x[0]*x[0]+p[1]*x[1], x[0] ]

henon = AriadneFunction( HenonFunction( [1.5,0.375] ) )
\endcode

Unfortunately, since all calls to the function require the Python interpreter, function evaluations will be much less efficient than a native C++

It would be nice to have a script in which a function could be specified in C++ (or some other function description language) and directly linked into the Python library. Ideally it would be possible to make a user-specific library of C++ functions and alongside this a separate user-specific library of Python bindings. However, for reasons relating to how Python performs symbol table lookup, it may be impossible to import user-defined C++ functions into Python without re-linking the Python interface. Help on this issue would be appreciated.




*/
