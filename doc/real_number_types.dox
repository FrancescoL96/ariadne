/***************************************************************************
 *            real_number_types.dox
 *
 *  Copyright  2004-7  Pieter Collins
 *
 ****************************************************************************/

/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */



/*! \file real_number_types.dox
 *  \brief Documentation on real number types
 */
#include "../include/multi_index.h"

namespace Ariadne {

/*!

\page numeric_page Number Types (Outdated)

\section Introduction

%Ariadne currently supports three different types for representing real numbers,
the \ref Real type, representing computable real numbers exactly,
the \ref Float type, representing floating-point approximations to a real number,
and the \ref Interval type, representing a range of possible values for a real number.
The Float and Interval types currently use the built-in \a double precision
floating-point type, but could be extended to use multiple-precision types
such as provided by the MPFR library.

Additionally, \ref Integer and \ref Rational types are supported. A \a Dyadic
type could in principle also be supported.

\section arithmeticoperators Arithmetical Operators and Aliases

The following aliases are used for arithmetical operations:
  <dl><dt><dd><tt>neg(x)</tt> is equivalent to <tt>-x</tt>
      <dt><dd><tt>rec(x)</tt> is equivalent to <tt>1/x</tt>
      <dt><dd><tt>add(x,y)</tt> is equivalent to <tt>x+y</tt>
      <dt><dd><tt>sub(x,y)</tt> is equivalent to <tt>x-y</tt>
      <dt><dd><tt>mul(x,y)</tt> is equivalent to <tt>x*y</tt>
      <dt><dd><tt>div(x,y)</tt> is equivalent to <tt>x/y</tt>


\section floatingpointtypes Floating-Point Number Types

In numerical analysis, real numbers are traditionally described by floating-point types \a float and \a double.
The set of elements which can be represented by these types is <em>finite</em>.
Arithmetic operations can only be performed approximately to maximal precision determined by the data type.
However, these types have the advantage of requiring a known amount of memory, which means they can be statically
allocated, and having hardware-supported arithmetical approximations. This makes them especially suitable in
situations where execution speed and memory usage are more important than a knowledge of the computational accuracy.

\subsection multipleprecisionfloat Multiple-precision floating-point types.

If we have a problem for which a fixed-precision type is not sufficient to obtain an accurate answer,
we can switch to a \em multiple-precision type. The semantics of arithmetic on multiple-precision types
is mostly the same as that of a fixed-precision type; arithmetic is approximate, and the default is to
return an interval. However, a multiple-precision type has a
<dl><dt><dd><tt>Float::set_precision(unsigned int)</tt></dl>
method, which sets the precision to which the type can store its result.
Using a higher precision yields a more accurate answer. Further, the result of an
arithmetic operation is guarenteed to converge as the precision is increased.

For efficiency, all elements of an array of a multiple precision type

\subsection arbitraryprecisionfloat Arbitrary-precision floating-point types.

An arbitrary precision floating-point type is a template class whose precision
is a template parameter. Such a class can be implemented using a
multiple-precision type, but has the advantage that it does not need to
dynamically-allocate memory.

Currently, there are no multiple- or arbitrary-precision floating-point types
in %Ariadne.

\section floatingpointarithmetic Floating-Point Arithmetic

For a package such as %Ariadne, in which we are concerned with keeping track of numerical errors,
it is dangerous to use the %Float type directly.
However, in some cases it is appropriate to use these types. Instead, we provide four different arithmetic operations for
the same type. We can specify that the result can be rounded up or down, or that the result
should be rounded to the nearest representable value. However, the default option is to
<em>return a float</em> containing an approximate value of the operation.
To summarize, we have the following
operations.
 - Exact arithmetic where possible:
   <dl><dt><dd><tt>%Float neg_exact(Float);</tt>
       <dt><dd><tt>%Float neg(Float);</tt>
   </dl>

 - Approximate and rounded arithmetic:
   <dl><dt><dd><tt>%Float add_approx(Float,Float);</tt>
       <dt><dd><tt>%Float add_near(Float,Float);</tt>
       <dt><dd><tt>%Float add_down(Float,Float);</tt>
       <dt><dd><tt>%Float add_up(Float,Float);</tt>
   </dl>

 - Arithmetic in the <em>current rounding mode</em>:
   <dl><dt><dd><tt>%Float add_rnd(Float,Float);</tt>
       <dt><dd><tt>%Float add_opp(Float,Float);</tt>
   </dl>

 - Floating-point arithmetic defaults to approximate:
    <dl><dt><dd><tt>%Float add(Float,Float);</tt></dl>

Algebraic and transcendental functions are provided with both rounded and interval versions.
 - Approximate and rounded algebraic transcendental functions:
   <dl><dt><dd><tt>%Float exp_approx(Float);</tt>
       <dt><dd><tt>%Float exp_down(Float);</tt>
       <dt><dd><tt>%Float exp_up(Float);</tt></dl>

 - Floating-point algebraic and transcendental operations default to approximate.
    <dl><dt><dd><tt>%Float exp(Float);</tt></dl>

The upper and lower rounded versions satisfy the condition
 <dl><dt><dd> <tt>f_down(x)</tt> <= <i>f(x)</i> <= <tt>f_up(x)</tt> </dl>
The approximate rounded version satisfies the implementation postcondition
 <dl><dt><dd> <tt>f_down(x)</tt> <= <tt>f_approx(x)</tt> <= <tt>f_up(x)</tt> </dl>
The nearest rounded version (if available) satisfies the conditions
 <dl><dt><dd> |<tt>f_near(x)</tt> - <i>f(x)</i>| <= <tt>f_up(x)</tt> - <i>f(x)</i>
       and  |<tt>f_near(x)</tt> - <i>f(x)</i>| <= <i>f(x)</i> - <tt>f_down(x)</tt> </dl>

Note that no other conditions are required of the implementation.
Hence a valid (but useless) implementation of \f$ \sin(x) \f$ is
<dl><dt><dd><tt>%Float sin_approx(Float x) { return 0.0; }</tt>
    <dt><dd><tt>%Float sin_down(Float x) { return -1.0; }</tt>
    <dt><dd><tt>%Float sin_up(Float x) { return 1.0; }</tt>
</dl>

\section intervalarithmetic Interval Arithmetic

 - %Interval arithmetic:
   <dl><dt><dd><tt>%Interval add(Interval,Interval);</tt></dl>

 - Automatic conversion to interval arithmetic:
   <dl><dt><dd><tt>%Interval add(Interval,Float);</tt>
       <dt><dd><tt>%Interval add(Float,Interval);</tt></dl>

For types based on double-precision point numbers, the arithmetical operators should follow IEEE standards.

 - %Interval algebraic and transcendental functions:
   <dl><dt><dd><tt>%Interval exp(Interval);</tt></dl>


%Interval arithmetic is commonly used in finite-precision computations to obtain guarenteed bounds for the result.
However, it can also be used in arbtitrary-precision computations to compute the image of basic sets.
The semantics is as follows:

\subsection finite_precision_interval Finite-precision interval arithmetic

Finite precision functions are of the form
<dl><dt><dd><tt>%Interval f(Interval);</tt></dl>
and satisfy the mathematical postcondition \f$ \forall x\in I,\ f(x)\in\f$\c f(I),
and the implementation postcondition <tt>I.contains(x)</tt> implies <tt>f(I).contains(f_approx(x))</tt>.

\subsection multiple_precision_interval Multiple-precision interval arithmetic

Multiple-precision interval functions follow the same conditions as fixed-precision
interval functions, together with the convergence criterion
that the length of <tt>f(I)</tt> approaches 0 as the precision of <tt>I</tt> approaches 0.
In particular, if <tt>I[n]</tt> is a sequence of intervals with nonempty
interior whose radius approaches 0, then the radius of <tt>f(I[n])</tt> approaches 0.


\subsection computablereal Computable Real Number Type

The \ref Real number type is a computable real number which from which
\ref Float and \ref Interval approximations can be extracted.

An implementation of the computable real number type may store a number in a form so that it can be
recovered to any desired precision. This is typically acheived by expressing
the number as a formula in terms of other arbitrary-precision or exact number
types. However, the high computational overhead of such numbers makes them
impractical for describing higher-order types, such as matrices or sets.

Arbitrary-precision numbers may be used to store constants occurring in a
system definition.

The \ref Real number type may be implemented as an arbitrary precision type.
It supports conversion to the \a Float and \a Interval types.

\section exactarithmetic Exact Arithmetic Types.

Elements of a countable set of numbers, such as integer, dyadic, rational or algebraic numbers,
may be stored using a finite amount of data, though the size of the data depends on the
element used. Hence in an array of an exact arithmetic type, each element needs to be
dynamically allocated, which is expensive in terms of spacial overhead.
Since these sets are typically closed under arithmetical operations,
arithmetic can be performed exactly for these types. Hence these types are
appropriate where time and space overhead are not at a premium.

Since these types require arbitrarily
large amounts of memory which is typically dynamically allocated, and hardware support for arithmetic does not
exist, they are typically less efficient than the fixed-precision and multiple-precision types.

In %Ariadne, we support arithmetic on the Rational number type, but no algebraic or transcendental functions.
This type is primarily useful for testing.

Exact arithmetic operators:
<dl><dt><dd><tt>%Rational operator-(Rational);</tt>
    <dt><dd><tt>%Rational operator+(Rational,Rational);</tt>
</dl>


A Dyadic type does not in general support exact division.
The exception is that division by a power of \f$2\f$ yields an exact answer.
Generic code intended for use with all exact arithmetic types should \em not use division, except by a power of two.

\section floatarithmetic Floating-Point Types.

In Ariadne, rounded floating-point arithmetic is performed using rounded arithmetic.

Alternatives are to use round-to-nearest algorithms. Examples include Dekker's \texttt{Fast2Sum}, Møller & Knuths \texttt{TwoSum} the \texttt{TwoMulFMA} and Kahan's algorithm for $ad=bc$.
and Pichat, Ogita, Rump and Oishi's algorithm for the sum.




*/

} // namespace Ariadne
