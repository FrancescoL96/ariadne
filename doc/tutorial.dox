/***************************************************************************
 *            tutorial.dox
 *
 *  Copyright  2004-8  Pieter Collins
 *
 ****************************************************************************/

/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/*!

\file tutorial.dox
\brief Tutorial on %Ariadne's features (outdated).

\page tutorial_page Tutorial

\dontinclude tutorial.cc

In this tutorial, we show how to use %Ariadne to model and analyse a hybrid automaton model of a simple heating system.

\section tutorial_system_model The Hybrid Automaton Model

The system represents a heating system used to control the temperature in a room. The temperature is affected by to the external temperature, which is assumed to vary sinusoidally, and is controlled by a heater which may either be on or off. The heater is turned on whenever the temperature falls below a certain threshold, and is turned off whenever the temperature rises above a certain threshold.

The system has two discrete modes, \f$\textsc{On}\f$ and \f$\textsc{Off}\f$, representing the state of the heater. There are three events, \f$\textsc{TurnOn}\f$, \f$\textsc{TurnOff}\f$ and \f$\textsc{Midnight}\f$; the first two representing switching the heater, and the last being a reset of the clock at the beginning of a new day.

The system has two continuous variables, \em temperature \f$T\f$ and \em time-of-day \f$\tau\f$.
The system is described by three parameters, the heater power \f$H\f$, the insulation level \f$K\f$, the average external temperature \f$T_E\f$, the amplitude of the temperature fluctuations \f$T_A\f$.

\f[ \dot{T} = H + K(T_E + T_A\cos(2\pi t) - T); \quad \dot{t}=1. \f]

The heater is turned on whenever the temperature falls below \f$T_{\textsc{On}}\f$, and is turned off whenever the temperature rises above \f$T_{\textsc{Off}}\f$.



\section tutorial_building_system Building the Ariadne Hybrid Automaton

First, choose an ordering for the parameters and variables in each mode.
In this example, the same parameters and variables are used in each mode, so this is easy.

\skipline // System variables
\until p[6]

Now define the nonlinear functions used in the system definition.

\skipline // System dynamic
\until };
\until };

Next define the function creating the system.

\skipline create_
\until {

Create the HybridAutomaton object.

\skipline //
\until HybridAutomaton

Set the system parameters.

\skipline //
\until Ton_lower

Define the discrete states and discrete events.

\skipline //
\until heater_off
\until midnight

Create the nonlinear system dynamics.

\skipline //
\until heater_off_dynamic

Create the affine reset maps. Note that an affine function has the form \f$x\mapsto Ax+b\f$.

\skipline //
\until midnight_reset

Create the affine guard functions. Note that continuous dynamics is possible when \f$g(x)\leq0\f$, and discrete transitions are possible for \f$g(x)\geq0\f$.

\skipline //
\until midnight_guard

Create the system modes.

\skipline //
\until heater_off_dynamic

Create the system transitions

\skipline //
\until heater_turn_off_guard
\until heater_off


End of function

\skipline }



\section tutorial_hybrid_system_evolution Computing the Continuous Evolution

The following function creates a HybridEvolver object, which is a class which can compute system evolution.

\skipline create_evolver
\until }

We now compute the evolution of the system.
\skipline compute_evolution
\until {

Define the intial set and evolution time.

\skipline // Define the initial set
\until evolution_time

Compute the reachable and evolved sets.

\skipline evolver.reach_evolve

Compute the trajectories parameterised by time.

\skipline evolver.orbit

Write the sets to standard output and to a file.

\skipline write
\skipline plot

End of function

\skipline }



\section tutorial_hybrid_system_reachability Computing Reachable Sets

\skipline compute_reachable_sets
\until {

Create a ReachabilityAnalyser object.

\skipline analyser

Set the initial set.

\skipline initial_set
\until initial_set[

Set the evolution time.
\skipline reach_time

Compute lower-approximation to the finite-time evolved set.

\skipline lower_evolve
\skipline plot

Compute lower-approximation to the finite-time reachable set.

\skipline lower_reach

Compute over-approximation to the finite-time evolved set.

\skipline upper_evolve

Compute over-approximation to the finite-time reachable set.

\skipline upper_reach

Compute over-approximation to the infinite-time chain-reachable set.

\skipline chain_reach

End of function.

\skipline }

\section tutorial_main Main function

\skipline main(
\skipline {
\skipline // Create
\until }
*/

/*!

\page python_tutorial_page Python Tutorial

\section python_tutorial_linear_algebra LinearAlgebra


Vectors and matrices can be constructed by using Python list objects. Note that a string literal representing a Float must be possible to represent exactly. For example
\code
v=Vector( [1,2.2,Float(3.3),"4.5"] )
v=IntervalVector( [1,2.2,Float(3.3),"4.4",Interval(5.5,5.6) ] )
A=Matrix( [ [1,2.2,Float(3.3)], ["4.5",Float("5.75"),6.875] ] )
\endcode



\subsection python_tutorial_linear_algebra_slicing Slicing (Future addition)

In the future, it will be possible to create \c VectorSlice and \c MatrixSlice objects using Python's slicing operatior. As in Matlab and other C++ libraries, and unlike Python sequences, these operations return a "view" into the structure, and not a copy, so can be used for in-place modification.

The semantics of this operator have not been determined, since Python has different conventions from C++ libraries such as the STL \c valarray class, glas and uBlas \c vector classes and Matlab classes. For example, if \c v is the vector <c>[0,1,2,3,4,5,6,7,8,9]</c>, then different possibilities are

 - Python: <c> v[start:finish:stride] </c>  e.g. <c>v[1:6:2]</c> = <c>v[1:7:2]</c> = <c>[1,3,5]</c>;

 - C++ STL \c valarray : <c> v[slice(start,size,stride)]</c> e.g.  <c> v[slice(1,3,2)]</c>\c  = <c>[3,5,7]</c>;

 - C++ uBlas: \c <c> project(v,slice(start,stride,size)) </c>  e.g.  <c>project(v,slice(1,2,3))</c> = <c>[1,3,5]</c>;

 - C++ glas: \c <c> slice(start,finish,stride)) </c>  e.g.  <c>v[slice(1,6,2)])</c> = <c>v[slice(1,7,2)])</c> = <c>[1,3,5]</c>;

 - Matlab: <c> v(first:stride:last) </c> with one-based indexing; e.g. <c>v(2:2:6)</c> = <c>v(2:2;7)</c> = <c>[1,3,5]</c>;

The main design decision is whether to use a single "Ariadne" slicing semantics which is used for any and all interfaces, or whether to use the natural semantics for the given environment. For the C++ API, we could provide STL \c valarray semantics <c> v[slice(start,size,stride=1)] </c> and Python semantics <c> v[range(start,finish,stride=1)] </c>.

\sa  \ref LinearAlgebraModule, Ariadne::Vector, Ariadne::Matrix

<br><br>




\section python_tutorial_function Functions

Currently %Ariadne provides a \c FunctionInterface class which specifies functions \f$f:\R^n\rightarrow\R^m\f$, i.e. functions of a single vector-valued variable.

There are currently two ways of creating user-defined functions, either via the Python interface or in C++.

\subsection tutorial_function_python Python functions

An %Ariadne function can be constructed directly from a Python function.
\code
def henon_function(x):
    return [ 1.5-x[0]*x[0]+0.375*x[1], x[0] ]
\endcode
Note that there must be a single argument of sequence type (i.e. supporting subscripting), and that the result must be a Python \c list object.

To prepare the Python function for use in %Ariadne, some meta-information is required.
\code
henon_function.result_size = 2
henon_function.argument_size = 2
\endcode

Finally, the function can be exported to the C++ wrapper.
\code
henon = AriadneFunction(henon_function)
\endcode
The newly-created function can be used exactly as a native C++ function, and supports automatic differentiation.
\code
x=Vector([1,0])
print henon.evaluate(x)
print henon.jacobian(x)
print henon.derivative(x,3)
\endcode

An %Ariadne function can actually be constructed from any Python object with methods \c "result_size", \c "argument_size" and the special method \c "__call__". For example, to create a parameterised version of the Henon map, use:
\code
class HenonFunction:
    def __init__(self,p):
        self.p=p
        self.result_size=2
        self.argument_size=2
    def __call__(self,x):
        return [ p[0]-x[0]*x[0]+p[1]*x[1], x[0] ]

henon = AriadneFunction( HenonFunction( [1.5,0.375] ) )
\endcode

Unfortunately, since all calls to the function require the Python interpreter, function evaluations will be much less efficient than a native C++

It would be nice to have a script in which a function could be specified in C++ (or some other function description language) and directly linked into the Python library. Ideally it would be possible to make a user-specific library of C++ functions and alongside this a separate user-specific library of Python bindings. However, for reasons relating to how Python performs symbol table lookup, it may be impossible to import user-defined C++ functions into Python without re-linking the Python interface. Help on this issue would be appreciated.




*/
